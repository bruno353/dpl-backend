generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL") 
}

model Task {
  id String @id @default(uuid())

  taskId String?  @unique //The id of the task onchain

  metadataHash String? //the metadata ipfs hash
  proposalId String?  //If this task is a draft task, so its not still a task, but has its own proposal Id

  isDraft  Boolean @default(false) //If this task is a draft task, so its not still a task, but has its own proposal Id
  isDraftCompleted  Boolean @default(false) //If this task is a draft task and it went through the voting and was approved

  status String? //The task status -> 0, 1, 2 - ['open', 'active', 'completed']

  type String? @default("Individual") //the type of the task -> individual or group

  skills String[] @default([]) //the skills of this task. ex: Frontend, Backend, Solidity

  skillsSearch String? //parameter mandatory to execute case insensitive searchs on the database - additional paramater to facilitate the searchs on database

  engineersRequirement String? //Of the total contributors needed, what is the tech requirement of this team (ex: 1 developer, 1 UI/UX, 1 PM) etc

  departament String?   //the departament of the task

  deadline String? //the task deadline in Unix timestamp

  description String? //task desc

  title String? //task title

  file String? //The file hash on ipfs (if its got any file linked to the task)

  links String[] //["{"title": "My video","url": "https://www.youtube.com/watch?v=zizonToFXDs"}"]

  applications String @default("[]") //A stringified array opf applications for the task -> struct OffChainApplication {address applicant; bool accepted; Reward[] reward;}

  payments Payment[]
  Application Application[]
  ApplicationOffChain ApplicationOffChain[]
  Submission Submission[]
  DraftVote DraftVote[]

  estimatedBudget String @default("0") //getting the value from the tokens we return the estimated budget in USD.

  contributorsNeeded String @default("1") //number of contributors need

  contributors String[] //["{"address": "0xa..."}"]

  executor String? //If the task was taken (application accepted and etc), who is the address that is in charge of doing the task

  projectLength String @default("Less than 1 week") //How much time is estimated to complete the task 

  metadataEdited Boolean @default(false) //When the metadata for this task is eddited, set this parameter as true
  budgetIncreased Boolean @default(false) //When the budget for this task is eddited, set this parameter as true
  deadlineIncreased Boolean @default(false) //When the deadline for this task is eddited, set this parameter as true

  createdAt    DateTime  @default(now())
  updatedAt    DateTime? @updatedAt

  startDate String? //the task draft start date of voting in Unix timestamp
  endDate String? //the task draft  end date of voting in Unix timestamp
  aragonMetadata String?
  
  creator String? //The task creator
  manager String? //The task manager
  
  hasSpamLink Boolean @default(false) //used to track if the task description has any pottencial link spam

  @@unique([proposalId, departament])

  @@map("task")
}

//Used to control the workflow of voting for draft tasks
model DraftVote {
  id String @id @default(uuid())

  address String? //The user address that voted

  votingPower String @default("1")

  voteOption String? //{        None,        Abstain,        Yes,        No    }  -> 0, 1, 2 or 3

  id_task String  
  task   Task  @relation(fields: [id_task], references: [id])

  @@unique([id_task, address])

  createdAt    DateTime  @default(now())
  updatedAt    DateTime? @updatedAt

  @@map("draftVote")
}

model TaskDraft {
  id String @id @default(uuid())

  proposalId String  @unique //The id of the task draft onchain

  status String? //The task status -> 0, 1 - ['open', 'closed']

  type String? @default("Individual") //the type of the task -> individual or group

  skills String[] @default([]) //the skills of this task. ex: Frontend, Backend, Solidity

  skillsSearch String? //parameter mandatory to execute case insensitive searchs on the database - additional paramater to facilitate the searchs on database

  engineersRequirement String? //Of the total contributors needed, what is the tech requirement of this team (ex: 1 developer, 1 UI/UX, 1 PM) etc

  departament String?   //the departament of the task

  deadline String? //the task deadline in Unix timestamp

  description String? //task desc

  title String? //task title

  file String? //The file hash on ipfs (if its got any file linked to the task)

  links String[] //["{"title": "My video","url": "https://www.youtube.com/watch?v=zizonToFXDs"}"]

  payments PaymentTaskDraft[]

  estimatedBudget String @default("0") //getting the value from the tokens we return the estimated budget in USD.

  contributorsNeeded String @default("1") //number of contributors need

  contributors String[] //["{"address": "0xa..."}"]

  executor String? //If the task was taken (application accepted and etc), who is the address that is in charge of doing the task

  projectLength String @default("Less than 1 week") //How much time is estimated to complete the task 

  startDate String? //the task draft start date of voting in Unix timestamp
  endDate String? //the task draft  end date of voting in Unix timestamp
  aragonMetadata String?

  hasSpamLink Boolean @default(false) //used to track if the task description has any pottencial link spam

  createdAt    DateTime  @default(now())
  updatedAt    DateTime? @updatedAt

  @@map("taskDraft")
}

model Departament {
  id String @id @default(uuid())

  name String?  @unique //The name of the departament

  addressTaskDrafts String? //The address of the task draft contract -> TaskDrafts.sol

  addressDAO String? //The address of the DAO contract -> IDAO.sol

  addressTokenListGovernance String? //The address of the tokenListGovernance contract -> TokenListGovernance.sol

  createdAt    DateTime  @default(now())
  updatedAt    DateTime? @updatedAt

  @@map("departament")
}

//Each verified contributor receives a NFT that is related to its voting power on the DAO departaments decisions, this parameter indicates what is (if the user is a verified contributor) tokenId of the nft
model VerifiedContributorToken {
  id String @id @default(uuid())

  tokenId String?  @unique //The tokenId
  departamentList String[] //List of addresses of the departaments TokenListGovernance.sol that this tokenId is member of

  userId String  
  user   User  @relation(fields: [userId], references: [id])
  
  createdAt    DateTime  @default(now())
  updatedAt    DateTime? @updatedAt

  @@map("verifiedContributorToken")
}


model PaymentTaskDraft {
    id String @id @default(uuid())

    tokenContract String //the token contract of the payment task
    amount String //The amount
    decimals String //Decimals of the smart-contract token

    proposalId String  
    task   TaskDraft  @relation(fields: [proposalId], references: [id])

    createdAt    DateTime  @default(now())
    updatedAt    DateTime? @updatedAt

    @@map("paymentTaskDraft")
}

model Payment {
    id String @id @default(uuid())

    tokenContract String //the token contract of the payment task
    amount String //The amount
    decimals String //Decimals of the smart-contract token

    taskId String  
    task   Task  @relation(fields: [taskId], references: [id])

    createdAt    DateTime  @default(now())
    updatedAt    DateTime? @updatedAt

    @@map("payment")
}

// Applications on-chain
model Application {
    id String @id @default(uuid())

    applicationId String //Application id onchain
    metadata String? //The metadata hash
    reward  String[] //Rewards: struct Reward {bool nextToken; address to; uint88 amount;}
    proposer String? //Proposer
    applicant String? //Applicant

    accepted Boolean @default(false) //If the application was accepted
    taken    Boolean @default(false) //After the application  is accepted, if the submitter took the task to work on it.

    metadataDescription String? //Application description
    metadataProposedBudget String? //Percentage of how much of the budget the user is asking for
    metadataAdditionalLink String?
    metadataDisplayName String? // The name that the user wants to show in his application

    timestamp String? //Timestamp Unix global in seconds of when the event was emitted;

    transactionHash String? //The hash of the transaction that emitted the vent
    blockNumber     String @default("0")

    taskId String  
    task   Task  @relation(fields: [taskId], references: [taskId])

    createdAt    DateTime  @default(now())
    updatedAt    DateTime? @updatedAt

    @@unique([taskId, applicationId]) //cannot exist application with same taskId and applicationId
    @@map("application")
}

// Applications off-chain
model ApplicationOffChain {
    id String @id @default(uuid())

    metadata String? //The metadata hash
    reward  String[] //Rewards: struct Reward {bool nextToken; address to; uint88 amount;}
    proposer String? //Proposer
    applicant String? //Applicant

    accepted Boolean @default(false) //If the application was accepted
    taken    Boolean @default(false) //After the application is accepted, if the submitter took the task to work on it.

    metadataDescription String? //Application description
    metadataProposedBudget String? //Percentage of how much of the budget the user is asking for
    metadataAdditionalLink String?
    metadataDisplayName String? // The name that the user wants to show in his application

    openmeshExpertUserId String  
    openmeshExpertUser   OpenmeshExpertUser  @relation(fields: [openmeshExpertUserId], references: [id])

    taskId String  
    task   Task  @relation(fields: [taskId], references: [taskId])

    offChain Boolean @default(true)

    createdAt    DateTime  @default(now())
    timestamp String?      @default("1698253") //Timestamp Unix global in seconds of when the event was emitted;

    updatedAt    DateTime? @updatedAt

    @@map("applicationOffChain")
}

model Submission {
    id String @id @default(uuid())

    submissionId String //Submission id onchain
    metadata String //The metadata hash
    proposer String //Proposer
    applicant String //Applicant

    accepted Boolean @default(false) //If the application was accepted
    reviewed Boolean @default(false) //If the application was reviewed

    review String? //The review outcome of this submission -> { None, Accepted, Rejected } -> 0, 1, 2

    metadataDescription String? //Application description
    metadataAdditionalLinks String[] @default([])

    metadataReviewFeedback String? //If its submission was reviewed, what was the feedback?
    metadataReview String? //If its submission was reviewed, what was the metadataHash
    timestampReview String? //If its submission was reviewed, what was the timestamp
    executorReview  String? //If its submission was reviewed, what was the executor

    timestamp String //Timestamp Unix global in seconds of when the event was emitted;

    transactionHash String //The hash of the transaction that emitted the vent
    blockNumber     String @default("0")

    taskId String  
    task   Task  @relation(fields: [taskId], references: [taskId])

    createdAt    DateTime  @default(now())
    updatedAt    DateTime? @updatedAt

    @@unique([taskId, submissionId]) //cannot exist submission with same taskId and submissionId
    @@map("submission")
}

//events emitted by the smart-contracts
model Event {
  id String @id @default(uuid())

  name String  //The event name
  data String  //The event data

  eventIndex String? //The logIndex
  transactionHash String? //The transaction hash
  blockNumber     String @default("0")

  taskId String? //If the event is related to a task

  address String? //Address related to the event (msg.sender / application sender etc)

  timestamp String? //Timestamp Unix global in seconds of when the event was emitted;

  createdAt    DateTime  @default(now())
  updatedAt    DateTime? @updatedAt

  @@unique([eventIndex, transactionHash, blockNumber]) //cannot exist event with same event info and transactionHash
  @@map("event")
}


//Users of the protocol
model User {
  id String @id @default(uuid())

  name String?   //The user display name
  address String? @unique //The user address

  verifiedContributorToken String? //Each verified contributor receives a NFT that is related to its voting power on the DAO departaments decisions, this parameter indicates what is (if the user is a verified contributor) tokenId of the nft

  profilePictureHash String? //The user profile picture - ipfs hash
  tags  String[] @default([]) //The user tags - "Data managment"; "Frontend"... etc
  links String [] @default([]) //The user links

  joinedSince String? //Timestamp Unix Global in seconds of when the user joined the protocol

  updatesNonce String @default("0") //Nonce that managens everytime a profile update is done, to control the message signing.

  jobSuccess String?   //Variable (0 - 100) that says the percentage of job success of the user - everytime a job he is in charge of is completed, it counts as a success
  totalEarned String? //Variable that says the total amount that the user earned based on the tasks that he completed (the estimated amount in USD)

  VerifiedContributorSubmission VerifiedContributorSubmission[]
  VerifiedContributorToken VerifiedContributorToken[]

  createdAt    DateTime  @default(now())
  updatedAt    DateTime? @updatedAt

  @@map("user")
}

//To become a verified-contributor, an user can submit a request.
model VerifiedContributorSubmission {
  id String @id @default(uuid())

  description String? //"Please give us some details about your qualifications to be a Verified Contributor"

  links String [] @default([]) //The submission links

  githubLogin String? //Ex: bruno353
  githubHTMLUrl String? //Ex: https://github.com/bruno353
  githubId String? //Ex: 82957886
  githubName String? //Ex: Bruno Santos
  githubEmail String? //Ex: tibiapro58@gmail.com
  githubAccessToken String?

  status String @default("pending") //the stauts of application - pending, approved, recused.

  userId String  
  user   User  @relation(fields: [userId], references: [id])

  createdAt    DateTime  @default(now())
  updatedAt    DateTime? @updatedAt

  @@map("verifiedContributorSubmission")
}

//Table utilized to store info about the speakers that are going to register on the calendly of the conference/hackathon 2023 - each registration is a "event"
model SpeakersRegistrationCalendly {
  id String @id @default(uuid())

  uri String? //Unique identifier that links with the event
  userName String? //The speaker name
  userEmail String? //The speaker email
  additionalInfo String? //Additional info like questions responses, descriptions etc
  eventName String? //The event name

  eventAt DateTime? //When the event is ocurring
  timezone String? //The event timezone time

  active Boolean @default(true) //if the event is active, if it was canceled or reschedule this will be false
  reschedule Boolean @default(false)

  createdAt    DateTime  @default(now())
  updatedAt    DateTime? @updatedAt

  @@map("speakersRegistrationCalendly")
}

model OpenmeshExpertUser {

  id       String @id @default(uuid())
  email    String @unique //unique
  password String

  companyName String?
  firstName String?
  lastName String?
  foundingYear Int?
  location String?
  website String?
  personalBlog String?
  githubLink String?
  tags String[]
  description String?
  scheduleCalendlyLink String?
  profilePictureHash String?
  isCompany Boolean @default(false) //if its not, it means its a individual.

  scheduleCall Boolean @default(false)

  userEnabled     Boolean @default(false)

  confirmedEmail       Boolean?  @default(false)
  hashConfirmEmail    String?
  registrationByOpenRD Boolean @default(false) // if the user registered through the openrd plataform. 
  timestampCodeEmail  String?   

  pageRedirect  String?

  RecoverPassword   RecoverPassword[]
  ApplicationOffChain ApplicationOffChain[]

  createdAt        DateTime  @default(now())
  updatedAt        DateTime? @updatedAt

  @@map("openmeshExpertUser")
}

model Session {

  id       String @id @default(uuid())
  sessionToken String   

  createdAt        DateTime  @default(now())
  updatedAt        DateTime? @updatedAt

  @@map("session")

}

model OpenmeshDataProviders {

  id       String @id @default(uuid())

  name String?
  description String?
  sql String?
  tags String[] @default([])
  useCases String[] @default([])
  popularity Int @default(0) //the greater, the more popular
  company String?
  live Boolean @default(false)
  isThirdParty Boolean @default(false)
  dataSpace String @default("0 MB")
  download Boolean @default(false)
  downloadCSVLink String @default("")
  liveLink String @default("wss://ws.tech.l3a.xyz")
  website String?
  addToXnodeMessage String @default("Coming Soon") 
  location String?
  foundingYear String?
  relevantDocs String?

  type String @default("data") // - the product type, ex: data, analytics, apis etc.

  dataCloudName String @default("US Virginia RE67243")
  dataCloudLink String @default("www.aws.com")

  logoURL String?
  logoWithCompanyNameURL String?

  dataGithubName String @default("Connector")
  dataGithubLink String @default("www.github.com")

  createdAt     DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  @@map("openmeshDataProviders")
}

model RecoverPassword { 
  id String @id @default(uuid())

  email     String
  txid      String @unique
  timeStamp String
  isValid   Boolean @default(true)

  
  openmeshExpertUserId String   
  openmeshExpertUser   OpenmeshExpertUser  @relation(fields: [openmeshExpertUserId], references: [id])

  createdAt     DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  @@map("recoverPassword")
}

